
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `BookingTable` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model BookingTable
 * 
 */
export type BookingTableModel = runtime.Types.Result.DefaultSelection<Prisma.$BookingTablePayload>

export type AggregateBookingTable = {
  _count: BookingTableCountAggregateOutputType | null
  _avg: BookingTableAvgAggregateOutputType | null
  _sum: BookingTableSumAggregateOutputType | null
  _min: BookingTableMinAggregateOutputType | null
  _max: BookingTableMaxAggregateOutputType | null
}

export type BookingTableAvgAggregateOutputType = {
  priceSnapshot: number | null
}

export type BookingTableSumAggregateOutputType = {
  priceSnapshot: number | null
}

export type BookingTableMinAggregateOutputType = {
  id: string | null
  bookingId: string | null
  tableId: string | null
  startTime: Date | null
  endTime: Date | null
  priceSnapshot: number | null
}

export type BookingTableMaxAggregateOutputType = {
  id: string | null
  bookingId: string | null
  tableId: string | null
  startTime: Date | null
  endTime: Date | null
  priceSnapshot: number | null
}

export type BookingTableCountAggregateOutputType = {
  id: number
  bookingId: number
  tableId: number
  startTime: number
  endTime: number
  priceSnapshot: number
  _all: number
}


export type BookingTableAvgAggregateInputType = {
  priceSnapshot?: true
}

export type BookingTableSumAggregateInputType = {
  priceSnapshot?: true
}

export type BookingTableMinAggregateInputType = {
  id?: true
  bookingId?: true
  tableId?: true
  startTime?: true
  endTime?: true
  priceSnapshot?: true
}

export type BookingTableMaxAggregateInputType = {
  id?: true
  bookingId?: true
  tableId?: true
  startTime?: true
  endTime?: true
  priceSnapshot?: true
}

export type BookingTableCountAggregateInputType = {
  id?: true
  bookingId?: true
  tableId?: true
  startTime?: true
  endTime?: true
  priceSnapshot?: true
  _all?: true
}

export type BookingTableAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which BookingTable to aggregate.
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BookingTables to fetch.
   */
  orderBy?: Prisma.BookingTableOrderByWithRelationInput | Prisma.BookingTableOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.BookingTableWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BookingTables from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BookingTables.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned BookingTables
  **/
  _count?: true | BookingTableCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: BookingTableAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: BookingTableSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: BookingTableMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: BookingTableMaxAggregateInputType
}

export type GetBookingTableAggregateType<T extends BookingTableAggregateArgs> = {
      [P in keyof T & keyof AggregateBookingTable]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateBookingTable[P]>
    : Prisma.GetScalarType<T[P], AggregateBookingTable[P]>
}




export type BookingTableGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.BookingTableWhereInput
  orderBy?: Prisma.BookingTableOrderByWithAggregationInput | Prisma.BookingTableOrderByWithAggregationInput[]
  by: Prisma.BookingTableScalarFieldEnum[] | Prisma.BookingTableScalarFieldEnum
  having?: Prisma.BookingTableScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: BookingTableCountAggregateInputType | true
  _avg?: BookingTableAvgAggregateInputType
  _sum?: BookingTableSumAggregateInputType
  _min?: BookingTableMinAggregateInputType
  _max?: BookingTableMaxAggregateInputType
}

export type BookingTableGroupByOutputType = {
  id: string
  bookingId: string
  tableId: string
  startTime: Date
  endTime: Date | null
  priceSnapshot: number
  _count: BookingTableCountAggregateOutputType | null
  _avg: BookingTableAvgAggregateOutputType | null
  _sum: BookingTableSumAggregateOutputType | null
  _min: BookingTableMinAggregateOutputType | null
  _max: BookingTableMaxAggregateOutputType | null
}

type GetBookingTableGroupByPayload<T extends BookingTableGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<BookingTableGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof BookingTableGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], BookingTableGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], BookingTableGroupByOutputType[P]>
      }
    >
  >



export type BookingTableWhereInput = {
  AND?: Prisma.BookingTableWhereInput | Prisma.BookingTableWhereInput[]
  OR?: Prisma.BookingTableWhereInput[]
  NOT?: Prisma.BookingTableWhereInput | Prisma.BookingTableWhereInput[]
  id?: Prisma.StringFilter<"BookingTable"> | string
  bookingId?: Prisma.StringFilter<"BookingTable"> | string
  tableId?: Prisma.StringFilter<"BookingTable"> | string
  startTime?: Prisma.DateTimeFilter<"BookingTable"> | Date | string
  endTime?: Prisma.DateTimeNullableFilter<"BookingTable"> | Date | string | null
  priceSnapshot?: Prisma.IntFilter<"BookingTable"> | number
  booking?: Prisma.XOR<Prisma.BookingScalarRelationFilter, Prisma.BookingWhereInput>
  table?: Prisma.XOR<Prisma.TableScalarRelationFilter, Prisma.TableWhereInput>
}

export type BookingTableOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  bookingId?: Prisma.SortOrder
  tableId?: Prisma.SortOrder
  startTime?: Prisma.SortOrder
  endTime?: Prisma.SortOrderInput | Prisma.SortOrder
  priceSnapshot?: Prisma.SortOrder
  booking?: Prisma.BookingOrderByWithRelationInput
  table?: Prisma.TableOrderByWithRelationInput
}

export type BookingTableWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.BookingTableWhereInput | Prisma.BookingTableWhereInput[]
  OR?: Prisma.BookingTableWhereInput[]
  NOT?: Prisma.BookingTableWhereInput | Prisma.BookingTableWhereInput[]
  bookingId?: Prisma.StringFilter<"BookingTable"> | string
  tableId?: Prisma.StringFilter<"BookingTable"> | string
  startTime?: Prisma.DateTimeFilter<"BookingTable"> | Date | string
  endTime?: Prisma.DateTimeNullableFilter<"BookingTable"> | Date | string | null
  priceSnapshot?: Prisma.IntFilter<"BookingTable"> | number
  booking?: Prisma.XOR<Prisma.BookingScalarRelationFilter, Prisma.BookingWhereInput>
  table?: Prisma.XOR<Prisma.TableScalarRelationFilter, Prisma.TableWhereInput>
}, "id">

export type BookingTableOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  bookingId?: Prisma.SortOrder
  tableId?: Prisma.SortOrder
  startTime?: Prisma.SortOrder
  endTime?: Prisma.SortOrderInput | Prisma.SortOrder
  priceSnapshot?: Prisma.SortOrder
  _count?: Prisma.BookingTableCountOrderByAggregateInput
  _avg?: Prisma.BookingTableAvgOrderByAggregateInput
  _max?: Prisma.BookingTableMaxOrderByAggregateInput
  _min?: Prisma.BookingTableMinOrderByAggregateInput
  _sum?: Prisma.BookingTableSumOrderByAggregateInput
}

export type BookingTableScalarWhereWithAggregatesInput = {
  AND?: Prisma.BookingTableScalarWhereWithAggregatesInput | Prisma.BookingTableScalarWhereWithAggregatesInput[]
  OR?: Prisma.BookingTableScalarWhereWithAggregatesInput[]
  NOT?: Prisma.BookingTableScalarWhereWithAggregatesInput | Prisma.BookingTableScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"BookingTable"> | string
  bookingId?: Prisma.StringWithAggregatesFilter<"BookingTable"> | string
  tableId?: Prisma.StringWithAggregatesFilter<"BookingTable"> | string
  startTime?: Prisma.DateTimeWithAggregatesFilter<"BookingTable"> | Date | string
  endTime?: Prisma.DateTimeNullableWithAggregatesFilter<"BookingTable"> | Date | string | null
  priceSnapshot?: Prisma.IntWithAggregatesFilter<"BookingTable"> | number
}

export type BookingTableCreateInput = {
  id?: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
  booking: Prisma.BookingCreateNestedOneWithoutBookingTablesInput
  table: Prisma.TableCreateNestedOneWithoutBookingTablesInput
}

export type BookingTableUncheckedCreateInput = {
  id?: string
  bookingId: string
  tableId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
  booking?: Prisma.BookingUpdateOneRequiredWithoutBookingTablesNestedInput
  table?: Prisma.TableUpdateOneRequiredWithoutBookingTablesNestedInput
}

export type BookingTableUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  bookingId?: Prisma.StringFieldUpdateOperationsInput | string
  tableId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableCreateManyInput = {
  id?: string
  bookingId: string
  tableId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  bookingId?: Prisma.StringFieldUpdateOperationsInput | string
  tableId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableListRelationFilter = {
  every?: Prisma.BookingTableWhereInput
  some?: Prisma.BookingTableWhereInput
  none?: Prisma.BookingTableWhereInput
}

export type BookingTableOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type BookingTableCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  bookingId?: Prisma.SortOrder
  tableId?: Prisma.SortOrder
  startTime?: Prisma.SortOrder
  endTime?: Prisma.SortOrder
  priceSnapshot?: Prisma.SortOrder
}

export type BookingTableAvgOrderByAggregateInput = {
  priceSnapshot?: Prisma.SortOrder
}

export type BookingTableMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  bookingId?: Prisma.SortOrder
  tableId?: Prisma.SortOrder
  startTime?: Prisma.SortOrder
  endTime?: Prisma.SortOrder
  priceSnapshot?: Prisma.SortOrder
}

export type BookingTableMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  bookingId?: Prisma.SortOrder
  tableId?: Prisma.SortOrder
  startTime?: Prisma.SortOrder
  endTime?: Prisma.SortOrder
  priceSnapshot?: Prisma.SortOrder
}

export type BookingTableSumOrderByAggregateInput = {
  priceSnapshot?: Prisma.SortOrder
}

export type BookingTableCreateNestedManyWithoutTableInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput> | Prisma.BookingTableCreateWithoutTableInput[] | Prisma.BookingTableUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutTableInput | Prisma.BookingTableCreateOrConnectWithoutTableInput[]
  createMany?: Prisma.BookingTableCreateManyTableInputEnvelope
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
}

export type BookingTableUncheckedCreateNestedManyWithoutTableInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput> | Prisma.BookingTableCreateWithoutTableInput[] | Prisma.BookingTableUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutTableInput | Prisma.BookingTableCreateOrConnectWithoutTableInput[]
  createMany?: Prisma.BookingTableCreateManyTableInputEnvelope
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
}

export type BookingTableUpdateManyWithoutTableNestedInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput> | Prisma.BookingTableCreateWithoutTableInput[] | Prisma.BookingTableUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutTableInput | Prisma.BookingTableCreateOrConnectWithoutTableInput[]
  upsert?: Prisma.BookingTableUpsertWithWhereUniqueWithoutTableInput | Prisma.BookingTableUpsertWithWhereUniqueWithoutTableInput[]
  createMany?: Prisma.BookingTableCreateManyTableInputEnvelope
  set?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  disconnect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  delete?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  update?: Prisma.BookingTableUpdateWithWhereUniqueWithoutTableInput | Prisma.BookingTableUpdateWithWhereUniqueWithoutTableInput[]
  updateMany?: Prisma.BookingTableUpdateManyWithWhereWithoutTableInput | Prisma.BookingTableUpdateManyWithWhereWithoutTableInput[]
  deleteMany?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
}

export type BookingTableUncheckedUpdateManyWithoutTableNestedInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput> | Prisma.BookingTableCreateWithoutTableInput[] | Prisma.BookingTableUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutTableInput | Prisma.BookingTableCreateOrConnectWithoutTableInput[]
  upsert?: Prisma.BookingTableUpsertWithWhereUniqueWithoutTableInput | Prisma.BookingTableUpsertWithWhereUniqueWithoutTableInput[]
  createMany?: Prisma.BookingTableCreateManyTableInputEnvelope
  set?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  disconnect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  delete?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  update?: Prisma.BookingTableUpdateWithWhereUniqueWithoutTableInput | Prisma.BookingTableUpdateWithWhereUniqueWithoutTableInput[]
  updateMany?: Prisma.BookingTableUpdateManyWithWhereWithoutTableInput | Prisma.BookingTableUpdateManyWithWhereWithoutTableInput[]
  deleteMany?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
}

export type BookingTableCreateNestedManyWithoutBookingInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput> | Prisma.BookingTableCreateWithoutBookingInput[] | Prisma.BookingTableUncheckedCreateWithoutBookingInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutBookingInput | Prisma.BookingTableCreateOrConnectWithoutBookingInput[]
  createMany?: Prisma.BookingTableCreateManyBookingInputEnvelope
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
}

export type BookingTableUncheckedCreateNestedManyWithoutBookingInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput> | Prisma.BookingTableCreateWithoutBookingInput[] | Prisma.BookingTableUncheckedCreateWithoutBookingInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutBookingInput | Prisma.BookingTableCreateOrConnectWithoutBookingInput[]
  createMany?: Prisma.BookingTableCreateManyBookingInputEnvelope
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
}

export type BookingTableUpdateManyWithoutBookingNestedInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput> | Prisma.BookingTableCreateWithoutBookingInput[] | Prisma.BookingTableUncheckedCreateWithoutBookingInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutBookingInput | Prisma.BookingTableCreateOrConnectWithoutBookingInput[]
  upsert?: Prisma.BookingTableUpsertWithWhereUniqueWithoutBookingInput | Prisma.BookingTableUpsertWithWhereUniqueWithoutBookingInput[]
  createMany?: Prisma.BookingTableCreateManyBookingInputEnvelope
  set?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  disconnect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  delete?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  update?: Prisma.BookingTableUpdateWithWhereUniqueWithoutBookingInput | Prisma.BookingTableUpdateWithWhereUniqueWithoutBookingInput[]
  updateMany?: Prisma.BookingTableUpdateManyWithWhereWithoutBookingInput | Prisma.BookingTableUpdateManyWithWhereWithoutBookingInput[]
  deleteMany?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
}

export type BookingTableUncheckedUpdateManyWithoutBookingNestedInput = {
  create?: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput> | Prisma.BookingTableCreateWithoutBookingInput[] | Prisma.BookingTableUncheckedCreateWithoutBookingInput[]
  connectOrCreate?: Prisma.BookingTableCreateOrConnectWithoutBookingInput | Prisma.BookingTableCreateOrConnectWithoutBookingInput[]
  upsert?: Prisma.BookingTableUpsertWithWhereUniqueWithoutBookingInput | Prisma.BookingTableUpsertWithWhereUniqueWithoutBookingInput[]
  createMany?: Prisma.BookingTableCreateManyBookingInputEnvelope
  set?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  disconnect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  delete?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  connect?: Prisma.BookingTableWhereUniqueInput | Prisma.BookingTableWhereUniqueInput[]
  update?: Prisma.BookingTableUpdateWithWhereUniqueWithoutBookingInput | Prisma.BookingTableUpdateWithWhereUniqueWithoutBookingInput[]
  updateMany?: Prisma.BookingTableUpdateManyWithWhereWithoutBookingInput | Prisma.BookingTableUpdateManyWithWhereWithoutBookingInput[]
  deleteMany?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
}

export type BookingTableCreateWithoutTableInput = {
  id?: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
  booking: Prisma.BookingCreateNestedOneWithoutBookingTablesInput
}

export type BookingTableUncheckedCreateWithoutTableInput = {
  id?: string
  bookingId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableCreateOrConnectWithoutTableInput = {
  where: Prisma.BookingTableWhereUniqueInput
  create: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput>
}

export type BookingTableCreateManyTableInputEnvelope = {
  data: Prisma.BookingTableCreateManyTableInput | Prisma.BookingTableCreateManyTableInput[]
  skipDuplicates?: boolean
}

export type BookingTableUpsertWithWhereUniqueWithoutTableInput = {
  where: Prisma.BookingTableWhereUniqueInput
  update: Prisma.XOR<Prisma.BookingTableUpdateWithoutTableInput, Prisma.BookingTableUncheckedUpdateWithoutTableInput>
  create: Prisma.XOR<Prisma.BookingTableCreateWithoutTableInput, Prisma.BookingTableUncheckedCreateWithoutTableInput>
}

export type BookingTableUpdateWithWhereUniqueWithoutTableInput = {
  where: Prisma.BookingTableWhereUniqueInput
  data: Prisma.XOR<Prisma.BookingTableUpdateWithoutTableInput, Prisma.BookingTableUncheckedUpdateWithoutTableInput>
}

export type BookingTableUpdateManyWithWhereWithoutTableInput = {
  where: Prisma.BookingTableScalarWhereInput
  data: Prisma.XOR<Prisma.BookingTableUpdateManyMutationInput, Prisma.BookingTableUncheckedUpdateManyWithoutTableInput>
}

export type BookingTableScalarWhereInput = {
  AND?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
  OR?: Prisma.BookingTableScalarWhereInput[]
  NOT?: Prisma.BookingTableScalarWhereInput | Prisma.BookingTableScalarWhereInput[]
  id?: Prisma.StringFilter<"BookingTable"> | string
  bookingId?: Prisma.StringFilter<"BookingTable"> | string
  tableId?: Prisma.StringFilter<"BookingTable"> | string
  startTime?: Prisma.DateTimeFilter<"BookingTable"> | Date | string
  endTime?: Prisma.DateTimeNullableFilter<"BookingTable"> | Date | string | null
  priceSnapshot?: Prisma.IntFilter<"BookingTable"> | number
}

export type BookingTableCreateWithoutBookingInput = {
  id?: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
  table: Prisma.TableCreateNestedOneWithoutBookingTablesInput
}

export type BookingTableUncheckedCreateWithoutBookingInput = {
  id?: string
  tableId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableCreateOrConnectWithoutBookingInput = {
  where: Prisma.BookingTableWhereUniqueInput
  create: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput>
}

export type BookingTableCreateManyBookingInputEnvelope = {
  data: Prisma.BookingTableCreateManyBookingInput | Prisma.BookingTableCreateManyBookingInput[]
  skipDuplicates?: boolean
}

export type BookingTableUpsertWithWhereUniqueWithoutBookingInput = {
  where: Prisma.BookingTableWhereUniqueInput
  update: Prisma.XOR<Prisma.BookingTableUpdateWithoutBookingInput, Prisma.BookingTableUncheckedUpdateWithoutBookingInput>
  create: Prisma.XOR<Prisma.BookingTableCreateWithoutBookingInput, Prisma.BookingTableUncheckedCreateWithoutBookingInput>
}

export type BookingTableUpdateWithWhereUniqueWithoutBookingInput = {
  where: Prisma.BookingTableWhereUniqueInput
  data: Prisma.XOR<Prisma.BookingTableUpdateWithoutBookingInput, Prisma.BookingTableUncheckedUpdateWithoutBookingInput>
}

export type BookingTableUpdateManyWithWhereWithoutBookingInput = {
  where: Prisma.BookingTableScalarWhereInput
  data: Prisma.XOR<Prisma.BookingTableUpdateManyMutationInput, Prisma.BookingTableUncheckedUpdateManyWithoutBookingInput>
}

export type BookingTableCreateManyTableInput = {
  id?: string
  bookingId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableUpdateWithoutTableInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
  booking?: Prisma.BookingUpdateOneRequiredWithoutBookingTablesNestedInput
}

export type BookingTableUncheckedUpdateWithoutTableInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  bookingId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableUncheckedUpdateManyWithoutTableInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  bookingId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableCreateManyBookingInput = {
  id?: string
  tableId: string
  startTime: Date | string
  endTime?: Date | string | null
  priceSnapshot: number
}

export type BookingTableUpdateWithoutBookingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
  table?: Prisma.TableUpdateOneRequiredWithoutBookingTablesNestedInput
}

export type BookingTableUncheckedUpdateWithoutBookingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tableId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}

export type BookingTableUncheckedUpdateManyWithoutBookingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tableId?: Prisma.StringFieldUpdateOperationsInput | string
  startTime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  priceSnapshot?: Prisma.IntFieldUpdateOperationsInput | number
}



export type BookingTableSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  bookingId?: boolean
  tableId?: boolean
  startTime?: boolean
  endTime?: boolean
  priceSnapshot?: boolean
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}, ExtArgs["result"]["bookingTable"]>

export type BookingTableSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  bookingId?: boolean
  tableId?: boolean
  startTime?: boolean
  endTime?: boolean
  priceSnapshot?: boolean
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}, ExtArgs["result"]["bookingTable"]>

export type BookingTableSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  bookingId?: boolean
  tableId?: boolean
  startTime?: boolean
  endTime?: boolean
  priceSnapshot?: boolean
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}, ExtArgs["result"]["bookingTable"]>

export type BookingTableSelectScalar = {
  id?: boolean
  bookingId?: boolean
  tableId?: boolean
  startTime?: boolean
  endTime?: boolean
  priceSnapshot?: boolean
}

export type BookingTableOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "bookingId" | "tableId" | "startTime" | "endTime" | "priceSnapshot", ExtArgs["result"]["bookingTable"]>
export type BookingTableInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}
export type BookingTableIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}
export type BookingTableIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  booking?: boolean | Prisma.BookingDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableDefaultArgs<ExtArgs>
}

export type $BookingTablePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "BookingTable"
  objects: {
    booking: Prisma.$BookingPayload<ExtArgs>
    table: Prisma.$TablePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    bookingId: string
    tableId: string
    startTime: Date
    endTime: Date | null
    priceSnapshot: number
  }, ExtArgs["result"]["bookingTable"]>
  composites: {}
}

export type BookingTableGetPayload<S extends boolean | null | undefined | BookingTableDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$BookingTablePayload, S>

export type BookingTableCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<BookingTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: BookingTableCountAggregateInputType | true
  }

export interface BookingTableDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingTable'], meta: { name: 'BookingTable' } }
  /**
   * Find zero or one BookingTable that matches the filter.
   * @param {BookingTableFindUniqueArgs} args - Arguments to find a BookingTable
   * @example
   * // Get one BookingTable
   * const bookingTable = await prisma.bookingTable.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends BookingTableFindUniqueArgs>(args: Prisma.SelectSubset<T, BookingTableFindUniqueArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one BookingTable that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {BookingTableFindUniqueOrThrowArgs} args - Arguments to find a BookingTable
   * @example
   * // Get one BookingTable
   * const bookingTable = await prisma.bookingTable.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends BookingTableFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, BookingTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first BookingTable that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableFindFirstArgs} args - Arguments to find a BookingTable
   * @example
   * // Get one BookingTable
   * const bookingTable = await prisma.bookingTable.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends BookingTableFindFirstArgs>(args?: Prisma.SelectSubset<T, BookingTableFindFirstArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first BookingTable that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableFindFirstOrThrowArgs} args - Arguments to find a BookingTable
   * @example
   * // Get one BookingTable
   * const bookingTable = await prisma.bookingTable.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends BookingTableFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, BookingTableFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more BookingTables that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all BookingTables
   * const bookingTables = await prisma.bookingTable.findMany()
   * 
   * // Get first 10 BookingTables
   * const bookingTables = await prisma.bookingTable.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const bookingTableWithIdOnly = await prisma.bookingTable.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends BookingTableFindManyArgs>(args?: Prisma.SelectSubset<T, BookingTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a BookingTable.
   * @param {BookingTableCreateArgs} args - Arguments to create a BookingTable.
   * @example
   * // Create one BookingTable
   * const BookingTable = await prisma.bookingTable.create({
   *   data: {
   *     // ... data to create a BookingTable
   *   }
   * })
   * 
   */
  create<T extends BookingTableCreateArgs>(args: Prisma.SelectSubset<T, BookingTableCreateArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many BookingTables.
   * @param {BookingTableCreateManyArgs} args - Arguments to create many BookingTables.
   * @example
   * // Create many BookingTables
   * const bookingTable = await prisma.bookingTable.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends BookingTableCreateManyArgs>(args?: Prisma.SelectSubset<T, BookingTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many BookingTables and returns the data saved in the database.
   * @param {BookingTableCreateManyAndReturnArgs} args - Arguments to create many BookingTables.
   * @example
   * // Create many BookingTables
   * const bookingTable = await prisma.bookingTable.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many BookingTables and only return the `id`
   * const bookingTableWithIdOnly = await prisma.bookingTable.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends BookingTableCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, BookingTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a BookingTable.
   * @param {BookingTableDeleteArgs} args - Arguments to delete one BookingTable.
   * @example
   * // Delete one BookingTable
   * const BookingTable = await prisma.bookingTable.delete({
   *   where: {
   *     // ... filter to delete one BookingTable
   *   }
   * })
   * 
   */
  delete<T extends BookingTableDeleteArgs>(args: Prisma.SelectSubset<T, BookingTableDeleteArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one BookingTable.
   * @param {BookingTableUpdateArgs} args - Arguments to update one BookingTable.
   * @example
   * // Update one BookingTable
   * const bookingTable = await prisma.bookingTable.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends BookingTableUpdateArgs>(args: Prisma.SelectSubset<T, BookingTableUpdateArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more BookingTables.
   * @param {BookingTableDeleteManyArgs} args - Arguments to filter BookingTables to delete.
   * @example
   * // Delete a few BookingTables
   * const { count } = await prisma.bookingTable.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends BookingTableDeleteManyArgs>(args?: Prisma.SelectSubset<T, BookingTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more BookingTables.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many BookingTables
   * const bookingTable = await prisma.bookingTable.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends BookingTableUpdateManyArgs>(args: Prisma.SelectSubset<T, BookingTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more BookingTables and returns the data updated in the database.
   * @param {BookingTableUpdateManyAndReturnArgs} args - Arguments to update many BookingTables.
   * @example
   * // Update many BookingTables
   * const bookingTable = await prisma.bookingTable.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more BookingTables and only return the `id`
   * const bookingTableWithIdOnly = await prisma.bookingTable.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends BookingTableUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, BookingTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one BookingTable.
   * @param {BookingTableUpsertArgs} args - Arguments to update or create a BookingTable.
   * @example
   * // Update or create a BookingTable
   * const bookingTable = await prisma.bookingTable.upsert({
   *   create: {
   *     // ... data to create a BookingTable
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the BookingTable we want to update
   *   }
   * })
   */
  upsert<T extends BookingTableUpsertArgs>(args: Prisma.SelectSubset<T, BookingTableUpsertArgs<ExtArgs>>): Prisma.Prisma__BookingTableClient<runtime.Types.Result.GetResult<Prisma.$BookingTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of BookingTables.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableCountArgs} args - Arguments to filter BookingTables to count.
   * @example
   * // Count the number of BookingTables
   * const count = await prisma.bookingTable.count({
   *   where: {
   *     // ... the filter for the BookingTables we want to count
   *   }
   * })
  **/
  count<T extends BookingTableCountArgs>(
    args?: Prisma.Subset<T, BookingTableCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], BookingTableCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a BookingTable.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends BookingTableAggregateArgs>(args: Prisma.Subset<T, BookingTableAggregateArgs>): Prisma.PrismaPromise<GetBookingTableAggregateType<T>>

  /**
   * Group by BookingTable.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BookingTableGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends BookingTableGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: BookingTableGroupByArgs['orderBy'] }
      : { orderBy?: BookingTableGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, BookingTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the BookingTable model
 */
readonly fields: BookingTableFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for BookingTable.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__BookingTableClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  booking<T extends Prisma.BookingDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.BookingDefaultArgs<ExtArgs>>): Prisma.Prisma__BookingClient<runtime.Types.Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  table<T extends Prisma.TableDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TableDefaultArgs<ExtArgs>>): Prisma.Prisma__TableClient<runtime.Types.Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the BookingTable model
 */
export interface BookingTableFieldRefs {
  readonly id: Prisma.FieldRef<"BookingTable", 'String'>
  readonly bookingId: Prisma.FieldRef<"BookingTable", 'String'>
  readonly tableId: Prisma.FieldRef<"BookingTable", 'String'>
  readonly startTime: Prisma.FieldRef<"BookingTable", 'DateTime'>
  readonly endTime: Prisma.FieldRef<"BookingTable", 'DateTime'>
  readonly priceSnapshot: Prisma.FieldRef<"BookingTable", 'Int'>
}
    

// Custom InputTypes
/**
 * BookingTable findUnique
 */
export type BookingTableFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter, which BookingTable to fetch.
   */
  where: Prisma.BookingTableWhereUniqueInput
}

/**
 * BookingTable findUniqueOrThrow
 */
export type BookingTableFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter, which BookingTable to fetch.
   */
  where: Prisma.BookingTableWhereUniqueInput
}

/**
 * BookingTable findFirst
 */
export type BookingTableFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter, which BookingTable to fetch.
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BookingTables to fetch.
   */
  orderBy?: Prisma.BookingTableOrderByWithRelationInput | Prisma.BookingTableOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for BookingTables.
   */
  cursor?: Prisma.BookingTableWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BookingTables from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BookingTables.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of BookingTables.
   */
  distinct?: Prisma.BookingTableScalarFieldEnum | Prisma.BookingTableScalarFieldEnum[]
}

/**
 * BookingTable findFirstOrThrow
 */
export type BookingTableFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter, which BookingTable to fetch.
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BookingTables to fetch.
   */
  orderBy?: Prisma.BookingTableOrderByWithRelationInput | Prisma.BookingTableOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for BookingTables.
   */
  cursor?: Prisma.BookingTableWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BookingTables from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BookingTables.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of BookingTables.
   */
  distinct?: Prisma.BookingTableScalarFieldEnum | Prisma.BookingTableScalarFieldEnum[]
}

/**
 * BookingTable findMany
 */
export type BookingTableFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter, which BookingTables to fetch.
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BookingTables to fetch.
   */
  orderBy?: Prisma.BookingTableOrderByWithRelationInput | Prisma.BookingTableOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing BookingTables.
   */
  cursor?: Prisma.BookingTableWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BookingTables from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BookingTables.
   */
  skip?: number
  distinct?: Prisma.BookingTableScalarFieldEnum | Prisma.BookingTableScalarFieldEnum[]
}

/**
 * BookingTable create
 */
export type BookingTableCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * The data needed to create a BookingTable.
   */
  data: Prisma.XOR<Prisma.BookingTableCreateInput, Prisma.BookingTableUncheckedCreateInput>
}

/**
 * BookingTable createMany
 */
export type BookingTableCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many BookingTables.
   */
  data: Prisma.BookingTableCreateManyInput | Prisma.BookingTableCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * BookingTable createManyAndReturn
 */
export type BookingTableCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * The data used to create many BookingTables.
   */
  data: Prisma.BookingTableCreateManyInput | Prisma.BookingTableCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * BookingTable update
 */
export type BookingTableUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * The data needed to update a BookingTable.
   */
  data: Prisma.XOR<Prisma.BookingTableUpdateInput, Prisma.BookingTableUncheckedUpdateInput>
  /**
   * Choose, which BookingTable to update.
   */
  where: Prisma.BookingTableWhereUniqueInput
}

/**
 * BookingTable updateMany
 */
export type BookingTableUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update BookingTables.
   */
  data: Prisma.XOR<Prisma.BookingTableUpdateManyMutationInput, Prisma.BookingTableUncheckedUpdateManyInput>
  /**
   * Filter which BookingTables to update
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * Limit how many BookingTables to update.
   */
  limit?: number
}

/**
 * BookingTable updateManyAndReturn
 */
export type BookingTableUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * The data used to update BookingTables.
   */
  data: Prisma.XOR<Prisma.BookingTableUpdateManyMutationInput, Prisma.BookingTableUncheckedUpdateManyInput>
  /**
   * Filter which BookingTables to update
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * Limit how many BookingTables to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * BookingTable upsert
 */
export type BookingTableUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * The filter to search for the BookingTable to update in case it exists.
   */
  where: Prisma.BookingTableWhereUniqueInput
  /**
   * In case the BookingTable found by the `where` argument doesn't exist, create a new BookingTable with this data.
   */
  create: Prisma.XOR<Prisma.BookingTableCreateInput, Prisma.BookingTableUncheckedCreateInput>
  /**
   * In case the BookingTable was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.BookingTableUpdateInput, Prisma.BookingTableUncheckedUpdateInput>
}

/**
 * BookingTable delete
 */
export type BookingTableDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
  /**
   * Filter which BookingTable to delete.
   */
  where: Prisma.BookingTableWhereUniqueInput
}

/**
 * BookingTable deleteMany
 */
export type BookingTableDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which BookingTables to delete
   */
  where?: Prisma.BookingTableWhereInput
  /**
   * Limit how many BookingTables to delete.
   */
  limit?: number
}

/**
 * BookingTable without action
 */
export type BookingTableDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BookingTable
   */
  select?: Prisma.BookingTableSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BookingTable
   */
  omit?: Prisma.BookingTableOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingTableInclude<ExtArgs> | null
}
