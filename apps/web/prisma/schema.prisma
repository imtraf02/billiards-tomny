generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Enums
enum Role {
  ADMIN
  STAFF
  CUSTOMER
}

enum TableType {
  POOL
  CAROM
  SNOOKER
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  RESERVED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum OrderStatus {
  PENDING
  PREPARING
  DELIVERED
  CANCELLED
}

// Models

model User {
  id        String   @id @default(uuid(7))
  name      String
  phone     String   @unique
  email     String?  @unique
  password  String // Hashed
  role      Role     @default(CUSTOMER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookings Booking[]
  orders   Order[] // Orders can be linked to user directly if not via booking, but usually via booking
}

model Table {
  id         String      @id @default(uuid(7))
  name       String      @unique // e.g. "Table 1", "VIP 2"
  type       TableType
  hourlyRate Decimal     @db.Decimal(10, 2)
  status     TableStatus @default(AVAILABLE)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  bookingTables BookingTable[]
}

model Category {
  id        String    @id @default(uuid(7))
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  products  Product[]
}

model Product {
  id          String   @id @default(uuid(7))
  categoryId  String
  name        String
  price       Decimal  @db.Decimal(10, 2)
  description String?
  imageUrl    String?
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  category   Category    @relation(fields: [categoryId], references: [id])
  orderItems OrderItem[]
}

model Booking {
  id          String        @id @default(uuid(7))
  userId      String? // Optional: Guest bookings
  startTime   DateTime
  endTime     DateTime? // Nullable if currently running
  status      BookingStatus @default(PENDING)
  totalAmount Decimal       @default(0) @db.Decimal(10, 2)
  note        String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  user          User?          @relation(fields: [userId], references: [id])
  bookingTables BookingTable[] // Relation to support multiple tables per booking
  orders        Order[]
}

model BookingTable {
  id            String    @id @default(uuid(7))
  bookingId     String
  tableId       String
  startTime     DateTime // Actual start time for this specific table in the booking
  endTime       DateTime?
  priceSnapshot Decimal   @db.Decimal(10, 2) // Hourly rate at the time of booking
  // Calculated cost for this specific table session can be stored or calculated on fly
  // cost          Decimal?   @db.Decimal(10, 2)

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  table   Table   @relation(fields: [tableId], references: [id])

  @@index([bookingId])
  @@index([tableId])
}

model Order {
  id          String      @id @default(uuid(7))
  bookingId   String? // Link to a booking session
  userId      String? // Link to user if ordering without a table (e.g. takeaway or waiting)
  status      OrderStatus @default(PENDING)
  totalAmount Decimal     @default(0) @db.Decimal(10, 2)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  booking    Booking?    @relation(fields: [bookingId], references: [id])
  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id            String  @id @default(uuid(7))
  orderId       String
  productId     String
  quantity      Int     @default(1)
  priceSnapshot Decimal @db.Decimal(10, 2) // Price at the time of order

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
}
